// Objects Exercises

// Basics of Object Creation and Access

// Create an empty object.
// Create an object with three properties: name, age, and city.
// Access the properties of an object using dot notation.
// Access the properties of an object using bracket notation.
// Update the value of a property in an object.
// Add a new property to an existing object.
// Delete a property from an object.
// Check if a property exists in an object.
// Iterate through the properties of an object and print them.
// Create an object with a nested object as one of its properties.

// Object Methods

// Create an object with a method that displays a message.
// Call a method of an object.
// Create an object with a method that calculates the area of a rectangle (height * width).
// Create an object with a method that calculates the circumference of a circle (2 * Ï€ * radius).
// Create an object with a method that converts a temperature from Celsius to Fahrenheit.
// Create an object with a method that converts a temperature from Fahrenheit to Celsius.
// Create an object with a method that concatenates two strings.
// Create an object with a method that reverses a string.
// Create an object with a method that checks if a string is a palindrome.
// Create an object with a method that sorts an array of numbers.

// Object Constructors and Prototypes

// Create a constructor function for a Person object with name and age properties.
// Create instances of the Person object using the constructor function.
// Add a method to the Person prototype to display the person's details.
// Create an object using the Object.create() method.
// Use the instanceof operator to check if an object is an instance of a specific constructor.
// Create an object with a property that is an array.
// Add elements to the array property of the object.
// Create an object with a property that is a function.
// Call the function property of the object.
// Create a prototype chain with multiple objects and constructors.

// Object Iteration and Manipulation

// Create an array of objects and sort them by a specific property.
// Filter an array of objects to get objects that meet a specific condition.
// Use the Object.keys() method to get an array of object keys.
// Use the Object.values() method to get an array of object values.
// Use the Object.entries() method to get an array of key-value pairs.
// Clone an object using the spread operator ({...}).
// Merge two objects into one.
// Convert an object into a JSON string.
// Parse a JSON string into an object.
// Iterate through an object's properties and calculate the sum of all numeric values.

// Object Inheritance and ES6 Classes

// Create a base class (Person) with properties (name, age) and a method (sayHello).
// Create a subclass (Student) that inherits from the base class and adds a new property (studentId).
// Override a method in the subclass.
// Use the super keyword to call a method from the parent class.
// Create multiple instances of the subclass.
// Create a class with a static method that counts the number of instances.
// Create a class with a getter and setter for a private property.
// Use the extends keyword to inherit from multiple classes (multiple inheritance).
// Create a mixin and apply it to a class.
// Use the instanceof operator to check class inheritance.


// Object Destructuring and Rest/Spread

// Destructure an object to extract specific properties.
// Destructure an object with nested properties.
// Use the rest operator to capture remaining object properties.
// Use the spread operator to merge two objects.
// Use object destructuring in function parameters.
// Create an object with default property values using destructuring.
// Destructure an object while renaming properties.
// Use object destructuring to swap the values of two variables.
// Destructure an object inside a loop.
// Destructure an object with default values and rest properties.

// Object Patterns and Best Practices

// Create an object using the module pattern (revealing module pattern).
// Create an object using the factory pattern.
// Create an object using the singleton pattern.
// Create an object using the constructor pattern with prototypes.
// Use Object.freeze() to make an object immutable.
// Use Object.seal() to prevent adding or deleting properties but allow changing values.
// Use Object.preventExtensions() to prevent adding new properties.
// Use Object.getOwnPropertyNames() to get all properties (including non-enumerable ones).
// Create an object with getter and setter properties.
// Use object destructuring with async/await and Promises.



// Advanced Object Topics

// Create an object that implements an iterator (Symbol.iterator).
// Create an object that implements a generator function.
// Use the Proxy object to intercept object operations.
// Create a deep clone of an object with nested objects.
// Implement object comparison to check if two objects are equivalent.
// Create an object with a private property using closures.
// Create an object with memoization to cache expensive function calls.
// Create an object that handles custom events and event listeners.
// Implement object pooling for efficient object reuse.
// Create an object that handles data validation and sanitization.

// Object-Related Data Structures

// Create a stack using an object (implement push and pop methods).
// Create a queue using an object (implement enqueue and dequeue methods).
// Create a linked list using objects (implement insert, delete, and search methods).
// Implement a hash table using objects (add, get, and remove key-value pairs).
// Create a binary tree using objects (insert, search, and traverse methods).
// Implement a graph using objects (add nodes and edges, perform depth-first and breadth-first traversal).
// Create a priority queue using objects (add items with priorities and remove the highest-priority item).
// Implement a trie (prefix tree) using objects (add words, search for prefixes and complete words).
// Create an object for a directed acyclic graph (DAG) and perform topological sorting.
// Design an object for a simple finite state machine (FSM) with states and transitions.
// Object-Related Algorithms

// Write a function to deep-merge two objects.
// Write a function to flatten a nested object into a single-level object.
// Implement a function to find the longest path in a tree-like object structure.
// Create a function to check if two objects have a deep equality (including nested objects).
// Implement a function to calculate the intersection of two sets represented as objects.
// Write a function to serialize an object into a URL query string.
// Create a function to deserialize a URL query string into an object.
// Write a function to convert a JSON-like string to an object.
// Implement a function to calculate the edit distance (Levenshtein distance) between two objects or strings.
// Create a function to find the shortest path in a graph represented as an object.


